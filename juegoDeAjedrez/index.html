<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ajedrez</title>
    <link rel="icon" type="image/x-icon" href="favicon.png">
    <style>
        * {
            margin: 0;
padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
}

        .main-container {
            display: flex;
gap: 30px;
            align-items: flex-start;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
}

        .game-header {
            text-align: center;
margin-bottom: 30px;
        }

        h1 {
            color: #333;
font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

        .turn-indicator {
            font-size: 1.2rem;
color: #666;
            font-weight: 500;
            padding: 10px 20px;
            background: linear-gradient(45deg, #f0f0f0, #e0e0e0);
            border-radius: 25px;
            display: inline-block;
            transition: all 0.3s ease;
}

        .chessboard {
            width: 560px;
height: 560px;
            border: 4px solid #8B4513;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
}

        .square {
            width: 70px;
height: 70px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s ease;
}

        .square.light {
            background: #f0d9b5;
}

        .square.dark {
            background: #b58863;
}

        .square.selected {
            background: #7fc045 !important;
box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .square.possible-move {
            background: rgba(127, 192, 69, 0.6) !important;
}

        .square.possible-move::after {
            content: '';
position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
}

        .square.can-capture {
            background: rgba(255, 0, 0, 0.6) !important;
}

        .square.can-capture::after {
            content: '';
position: absolute;
            top: 5px;
            left: 5px;
            right: 5px;
            bottom: 5px;
            border: 3px solid rgba(255, 0, 0, 0.8);
            border-radius: 5px;
}

        .piece {
            font-size: 3.5rem;
position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            user-select: none;
            transition: all 0.3s ease;
text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .piece:hover {
            transform: translate(-50%, -50%) scale(1.1);
filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.4));
        }

        .white { color: #fff;
}
        .black { color: #333;
}

        .reset-btn {
            margin-top: 30px;
            /* text-align: center; [cite_start]*/ /* [cite: 32] Reemplazado por flex */
            display: flex;
            justify-content: center;
            gap: 15px; /* Espacio entre los botones */
        }

        .reset-btn button {
            background: linear-gradient(45deg, #667eea, #764ba2);
color: white;
            border: none;
            padding: 15px 30px;
            font-size: 1.1rem;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .reset-btn button:hover {
            transform: translateY(-2px);
box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }

        /* Modal de promoci√≥n */
        .promotion-modal {
            position: fixed;
top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
z-index: 1000;
            backdrop-filter: blur(5px);
        }

        .promotion-modal.show {
            display: flex;
}

        .promotion-content {
            background: linear-gradient(135deg, #fff, #f8f8f8);
padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            min-width: 300px;
}

        .promotion-title {
            font-size: 1.5rem;
color: #333;
            margin-bottom: 20px;
            font-weight: 600;
        }

        .promotion-pieces {
            display: flex;
gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .promotion-piece {
            width: 80px;
height: 80px;
            background: linear-gradient(45deg, #f0f0f0, #e0e0e0);
            border: 3px solid #ddd;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
}

        .promotion-piece:hover {
            transform: translateY(-5px) scale(1.1);
border-color: #667eea;
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
}

        .promotion-piece.white { color: #fff; text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}
        .promotion-piece.black { color: #333; text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.3);
}

        /* Historial de movimientos */
        .moves-panel {
            background: rgba(255, 255, 255, 0.95);
border-radius: 20px;
            padding: 25px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            width: 280px;
            max-height: 600px;
            overflow: hidden;
display: flex;
            flex-direction: column;
        }

        .moves-header {
            text-align: center;
margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }

        .moves-title {
            font-size: 1.4rem;
font-weight: 600;
            color: #333;
            margin: 0;
        }

        .moves-counter {
            font-size: 0.9rem;
color: #666;
            margin-top: 5px;
        }

        .moves-list {
            flex: 1;
overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ccc #f0f0f0;
        }

        .moves-list::-webkit-scrollbar {
            width: 8px;
}

        .moves-list::-webkit-scrollbar-track {
            background: #f0f0f0;
border-radius: 4px;
        }

        .moves-list::-webkit-scrollbar-thumb {
            background: #ccc;
border-radius: 4px;
        }

        .move-pair {
            display: flex;
align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            border-radius: 10px;
            background: linear-gradient(45deg, #f8f9fa, #e9ecef);
            transition: all 0.2s ease;
}

        .move-pair:hover {
            background: linear-gradient(45deg, #e3f2fd, #bbdefb);
transform: translateX(5px);
        }

        .move-number {
            font-weight: 600;
color: #666;
            min-width: 25px;
            font-size: 0.85rem;
        }

        .move-white, .move-black {
            flex: 1;
text-align: center;
            font-weight: 500;
            font-size: 0.9rem;
            padding: 4px 8px;
            border-radius: 6px;
            margin: 0 2px;
}

        .move-white {
            background: rgba(255, 255, 255, 0.8);
color: #333;
        }

        .move-black {
            background: rgba(0, 0, 0, 0.1);
color: #333;
        }

        .move-special {
            font-style: italic;
color: #667eea !important;
        }

        .clear-moves {
            margin-top: 15px;
padding-top: 15px;
            border-top: 2px solid #eee;
            text-align: center;
            display: flex;
            gap: 10px;
            flex-direction: column;
}

        .clear-moves button {
            color: white;
border: none;
            padding: 8px 16px;
            font-size: 0.9rem;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
}

        .clear-moves .btn-undo {
            background: linear-gradient(45deg, #ffa726, #ff9800);
}

        .clear-moves .btn-copy {
            background: linear-gradient(45deg, #ab47bc, #9c27b0);
}

        .clear-moves .btn-download {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
}

        .clear-moves .btn-clear {
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
}

        .clear-moves button:hover {
            transform: translateY(-2px);
}

        .clear-moves .btn-undo:hover {
            box-shadow: 0 5px 15px rgba(255, 167, 38, 0.4);
}

        .clear-moves .btn-copy:hover {
            box-shadow: 0 5px 15px rgba(171, 71, 188, 0.4);
}

        .clear-moves .btn-download:hover {
            box-shadow: 0 5px 15px rgba(78, 205, 196, 0.4);
}

        .clear-moves .btn-clear:hover {
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
}

        .btn-disabled {
            opacity: 0.5;
cursor: not-allowed !important;
            transform: none !important;
        }

            @media (max-width: 640px) {
                .chessboard {
                    width: 320px;
height: 320px;
                }
                
                .square {
                    width: 40px;
height: 40px;
                }
                
                .piece {
                    font-size: 2rem;
}
                
                h1 {
                    font-size: 1.8rem;
}
            }

        /* --- ESTILOS A√ëADIDOS PARA VOLTEAR --- */

        /* Estilo para el nuevo bot√≥n de voltear */
        #flipBtn {
            background: linear-gradient(45deg, #02aab0, #00cdac);
        }

        #flipBtn:hover {
            box-shadow: 0 8px 25px rgba(2, 170, 176, 0.3);
        }

        /* Clase que se a√±ade al tablero para girarlo */
        .chessboard.board-flipped {
            /* Gira el contenedor del tablero 180 grados */
            transform: rotate(180deg);
            transition: transform 0.5s ease-in-out;
        }

        .chessboard.board-flipped .piece {
            /* Gira las piezas 180 grados para que se vean derechas */
            transform: translate(-50%, -50%) rotate(180deg);
        }
        
        /* Asegura que el efecto hover funcione bien cuando est√° girado */
        .chessboard.board-flipped .piece:hover {
            transform: translate(-50%, -50%) scale(1.1) rotate(180deg);
        }
        /* --- FIN DE ESTILOS A√ëADIDOS --- */
    </style>
</head>
<body>
    <div class="main-container">
        <div class="game-container">
            <div class="game-header">
                <h1>‚ôî Ajedrez ‚ôõ</h1>
		<p>Este es un set para aprender a jugar, no tiene motor de juegos,<br> el usuario debe mover tanto las piezas blancas como las negras</p>
                
<div class="turn-indicator" id="turnIndicator">Turno: Blancas</div>
            </div>
            
            <div class="chessboard" id="chessboard"></div>
            
            <div class="reset-btn">
                <button onclick="initializeBoard()">Nueva Partida</button>
                <button onclick="flipBoard()" id="flipBtn">Voltear Tablero (‚ü≥)</button>
            </div>
    
    </div>

        <aside class="moves-panel">
            <div class="moves-header">
                <h2 class="moves-title">üìù Historial</h2>
                <div class="moves-counter" id="movesCounter">Movimientos: 0</div>
		<div class="clear-moves">
                <button class="btn-undo" id="undoBtn" onclick="undoLastMove()">‚Ü∂ Deshacer (Ctrl+Z)</button>
		</div>
   
         </div>
            <div class="moves-list" id="movesList">
                <div style="text-align: center;
color: #999; font-style: italic; margin-top: 50px;">
                    Los movimientos aparecer√°n aqu√≠
                </div>
            </div>
            <div class="clear-moves">
                <button class="btn-copy" onclick="copyHistoryToClipboard()">üìã Copiar Historial</button>
           
     <button class="btn-download" onclick="downloadGameHistory()">üì• Descargar Historial</button>
                <button class="btn-clear" onclick="clearMoveHistory()">üóëÔ∏è Limpiar Historial</button>
            </div>
        </aside>
    </div>

    <div class="promotion-modal" id="promotionModal">
        <div class="promotion-content">
            <h3 class="promotion-title">¬°Promoci√≥n de Pe√≥n!</h3>
       
     <p style="margin-bottom: 20px; color: #666;">Elige la pieza en la que quieres convertir tu pe√≥n:</p>
            <div class="promotion-pieces" id="promotionPieces">
                </div>
        </div>
    </div>

    <script>
        // Piezas Unicode
        const pieces 
= {
            'K': '‚ôî', 'Q': '‚ôï', 'R': '‚ôñ', 'B': '‚ôó', 'N': '‚ôò', 'P': '‚ôô',
            'k': '‚ôö', 'q': '‚ôõ', 'r': '‚ôú', 'b': '‚ôù', 'n': '‚ôû', 'p': '‚ôü'
        };

        // Posici√≥n inicial del tablero
        const initialBoard = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
   
         ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
        
    ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];
let board = [];
        let currentPlayer = 'white';
        let selectedSquare = null;
        let possibleMoves = [];
let castlingRights = {
            white: { king: true, queenside: true, kingside: true },
            black: { king: true, queenside: true, kingside: true }
        };
let pendingPromotion = null;
        let moveHistory = [];
        let moveNumber = 1;
        let gameHistory = [];
// Para almacenar estados completos del tablero

        function initializeBoard() {
            board = initialBoard.map(row => [...row]);
currentPlayer = 'white';
            selectedSquare = null;
            possibleMoves = [];
            pendingPromotion = null;
            moveHistory = [];
            moveNumber = 1;
gameHistory = [];
            castlingRights = {
                white: { king: true, queenside: true, kingside: true },
                black: { king: true, queenside: true, kingside: true }
            };
// Guardar estado inicial
            saveGameState();
            
            hidePromotionModal();
            renderBoard();
            updateTurnIndicator();
            updateMovesDisplay();
updateUndoButton();
        }

        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
chessboard.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
if (selectedSquare && selectedSquare.row === row && selectedSquare.col === col) {
                        square.classList.add('selected');
}
                    
                    if (possibleMoves.some(move => move.row === row && move.col === col)) {
                        if (board[row][col]) {
                        
    square.classList.add('can-capture');
                        } else {
                            square.classList.add('possible-move');
}
                    }

                    if (board[row][col]) {
                        const piece = document.createElement('div');
piece.className = `piece ${isWhitePiece(board[row][col]) ? 'white' : 'black'}`;
                        piece.textContent = pieces[board[row][col]];
                        square.appendChild(piece);
}

                    square.addEventListener('click', () => handleSquareClick(row, col));
chessboard.appendChild(square);
                }
            }
        }

        function isPromotionSquare(row, piece) {
            // Peones blancos llegan a la fila 0 (octava fila)
            if (isWhitePiece(piece) && row === 0) return true;
// Peones negros llegan a la fila 7 (primera fila)
            if (!isWhitePiece(piece) && row === 7) return true;
return false;
        }

        function showPromotionModal(piece) {
            const modal = document.getElementById('promotionModal');
const piecesContainer = document.getElementById('promotionPieces');
            
            const isWhite = isWhitePiece(piece);
            const colorClass = isWhite ? 'white' : 'black';
const promotionOptions = [
                { symbol: isWhite ?
'‚ôï' : '‚ôõ', piece: isWhite ? 'Q' : 'q', name: 'Reina' },
                { symbol: isWhite ?
'‚ôñ' : '‚ôú', piece: isWhite ? 'R' : 'r', name: 'Torre' },
                { symbol: isWhite ?
'‚ôó' : '‚ôù', piece: isWhite ? 'B' : 'b', name: 'Alfil' },
                { symbol: isWhite ?
'‚ôò' : '‚ôû', piece: isWhite ? 'N' : 'n', name: 'Caballo' }
            ];
piecesContainer.innerHTML = '';
            promotionOptions.forEach(option => {
                const pieceElement = document.createElement('div');
                pieceElement.className = `promotion-piece ${colorClass}`;
                pieceElement.textContent = option.symbol;
                pieceElement.title = option.name;
                pieceElement.onclick = () => executePromotion(option.piece);
 
               piecesContainer.appendChild(pieceElement);
            });
modal.classList.add('show');
        }

        function hidePromotionModal() {
            const modal = document.getElementById('promotionModal');
modal.classList.remove('show');
        }

        function executePromotion(newPiece) {
            if (!pendingPromotion) return;
board[pendingPromotion.row][pendingPromotion.col] = newPiece;
            
            // Actualizar notaci√≥n con la promoci√≥n
            const promotionSymbol = getPieceSymbol(newPiece);
const lastMoveIndex = moveHistory.length - 1;
            if (lastMoveIndex >= 0) {
                moveHistory[lastMoveIndex].notation += `=${promotionSymbol}`;
}
            
            pendingPromotion = null;
hidePromotionModal();
            updateMovesDisplay();
            
            // Cambiar turno despu√©s de la promoci√≥n
            currentPlayer = currentPlayer === 'white' ?
'black' : 'white';
            
            // Guardar estado despu√©s de la promoci√≥n
            saveGameState();
renderBoard();
            updateTurnIndicator();
            updateUndoButton();
        }

        function generateMoveNotation(fromRow, fromCol, toRow, toCol, piece) {
            const pieceSymbol = getPieceSymbol(piece);
const fromSquare = getSquareNotation(fromRow, fromCol);
            const toSquare = getSquareNotation(toRow, toCol);
            const isCapture = board[toRow][toCol] !== null;
if (piece.toLowerCase() === 'p') {
                // Notaci√≥n de pe√≥n
                if (isCapture) {
                    return `${fromSquare[0]}x${toSquare}`;
} else {
                    return toSquare;
}
            } else {
                // Notaci√≥n de otras piezas
                if (isCapture) {
                    return `${pieceSymbol}x${toSquare}`;
} else {
                    return `${pieceSymbol}${toSquare}`;
}
            }
        }

        function getPieceSymbol(piece) {
            const symbols = { 
                'k': 'R', 'K': 'R',  // Rey
                'q': 'D', 'Q': 'D',  // Dama/Reina  
        
        'r': 'T', 'R': 'T',  // Torre
                'b': 'A', 'B': 'A',  // Alfil
                'n': 'C', 'N': 'C',  // Caballo
                'p': '', 'P': ''     // Pe√≥n (sin s√≠mbolo)
            };
return symbols[piece] || '';
        }

        function getSquareNotation(row, col) {
            const files = 'abcdefgh';
const ranks = '87654321';
            return files[col] + ranks[row];
        }

        function recordMove(notation, isSpecial = false) {
            const move = {
                notation,
                player: currentPlayer,
                isSpecial
            };
moveHistory.push(move);
            updateMovesDisplay();
        }

        function updateMovesDisplay() {
            const movesList = document.getElementById('movesList');
const movesCounter = document.getElementById('movesCounter');
            
            movesCounter.textContent = `Movimientos: ${moveHistory.length}`;
            
            if (moveHistory.length === 0) {
                movesList.innerHTML = '<div style="text-align: center; color: #999; font-style: italic; margin-top: 50px;">Los movimientos aparecer√°n aqu√≠</div>';
return;
            }
            
            let html = '';
for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
const whiteMove = moveHistory[i];
                const blackMove = moveHistory[i + 1];
html += `<div class="move-pair">
                    <div class="move-number">${moveNum}.</div>
                    <div class="move-white ${whiteMove?.isSpecial ? 'move-special' : ''}">${whiteMove?.notation ||
''}</div>
                    <div class="move-black ${blackMove?.isSpecial ? 'move-special' : ''}">${blackMove?.notation ||
''}</div>
                </div>`;
}
            
            movesList.innerHTML = html;
movesList.scrollTop = movesList.scrollHeight;
        }

        function handleSquareClick(row, col) {
            // Si hay una promoci√≥n pendiente, no permitir otros movimientos
            if (pendingPromotion) return;
if (selectedSquare && possibleMoves.some(move => move.row === row && move.col === col)) {
                // Verificar si es un enroque
                const selectedPiece = board[selectedSquare.row][selectedSquare.col];
const move = possibleMoves.find(move => move.row === row && move.col === col);
if (move && move.isCastling) {
                    // Ejecutar enroque
                    const castlingType = move.castlingType === 'kingside' ?
'O-O' : 'O-O-O';
                    recordMove(castlingType, true);
                    executeCastling(selectedSquare.row, selectedSquare.col, row, col);
                    finishTurn();
} else {
                    // Movimiento normal
                    const moveNotation = generateMoveNotation(selectedSquare.row, selectedSquare.col, row, col, selectedPiece);
recordMove(moveNotation);
                    
                    board[row][col] = board[selectedSquare.row][selectedSquare.col];
                    board[selectedSquare.row][selectedSquare.col] = null;
                    
                    // Verificar promoci√≥n de pe√≥n
                    if (selectedPiece.toLowerCase() === 'p' && isPromotionSquare(row, selectedPiece)) {
                        pendingPromotion = { row, col, piece: selectedPiece, moveNotation };
showPromotionModal(selectedPiece);
                        selectedSquare = null;
                        possibleMoves = [];
                        renderBoard();
                        return;
                    }
                    
                    // Actualizar derechos de enroque
                    updateCastlingRights(selectedSquare.row, selectedSquare.col, selectedPiece);
finishTurn();
                }
            } else if (board[row][col] && isPieceOfCurrentPlayer(board[row][col])) {
                // Seleccionar pieza
                selectedSquare = { row, col };
possibleMoves = getPossibleMoves(row, col);
                renderBoard();
            } else {
                // Deseleccionar
                selectedSquare = null;
possibleMoves = [];
                renderBoard();
            }
        }

        function finishTurn() {
            currentPlayer = currentPlayer === 'white' ?
'black' : 'white';
            selectedSquare = null;
            possibleMoves = [];
            
            // Guardar estado del juego despu√©s del movimiento
            saveGameState();
renderBoard();
            updateTurnIndicator();
            updateMovesDisplay();
            updateUndoButton();
        }

        function isPieceOfCurrentPlayer(piece) {
            return (currentPlayer === 'white' && isWhitePiece(piece)) ||
(currentPlayer === 'black' && !isWhitePiece(piece));
        }

        function isWhitePiece(piece) {
            return piece === piece.toUpperCase();
}

        function getPossibleMoves(row, col) {
            const piece = board[row][col];
if (!piece) return [];

            const moves = [];
            const pieceType = piece.toLowerCase();
switch (pieceType) {
                case 'p':
                    moves.push(...getPawnMoves(row, col, piece));
break;
                case 'r':
                    moves.push(...getRookMoves(row, col, piece));
break;
                case 'n':
                    moves.push(...getKnightMoves(row, col, piece));
break;
                case 'b':
                    moves.push(...getBishopMoves(row, col, piece));
break;
                case 'q':
                    moves.push(...getQueenMoves(row, col, piece));
break;
                case 'k':
                    moves.push(...getKingMoves(row, col, piece));
break;
            }

            return moves.filter(move => isValidMove(move.row, move.col, piece));
}

        function getPawnMoves(row, col, piece) {
            const moves = [];
const direction = isWhitePiece(piece) ? -1 : 1;
            const startRow = isWhitePiece(piece) ? 6 : 1;
// Movimiento hacia adelante
            if (isInBounds(row + direction, col) && !board[row + direction][col]) {
                moves.push({ row: row + direction, col });
// Movimiento doble desde posici√≥n inicial
                if (row === startRow && !board[row + 2 * direction][col]) {
                    moves.push({ row: row + 2 * direction, col });
}
            }

            // Capturas diagonales
            for (const colOffset of [-1, 1]) {
                const newRow = row + direction;
const newCol = col + colOffset;
                if (isInBounds(newRow, newCol) && board[newRow][newCol] && 
                    isWhitePiece(board[newRow][newCol]) !== isWhitePiece(piece)) {
                    moves.push({ row: newRow, col: newCol });
}
            }

            return moves;
}

        function getRookMoves(row, col, piece) {
            const moves = [];
const directions = [[0, 1], [0, -1], [1, 0], [-1, 0]];
for (const [rowDir, colDir] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + i * rowDir;
const newCol = col + i * colDir;

                    if (!isInBounds(newRow, newCol)) break;
if (!board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol });
} else {
                        if (isWhitePiece(board[newRow][newCol]) !== isWhitePiece(piece)) {
                            moves.push({ row: newRow, col: newCol });
}
                        break;
}
                }
            }

            return moves;
}

        function getKnightMoves(row, col, piece) {
            const moves = [];
const knightMoves = [
                [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                [1, -2], [1, 2], [2, -1], [2, 1]
            ];
for (const [rowOffset, colOffset] of knightMoves) {
                const newRow = row + rowOffset;
const newCol = col + colOffset;

                if (isInBounds(newRow, newCol) && 
                    (!board[newRow][newCol] || isWhitePiece(board[newRow][newCol]) !== isWhitePiece(piece))) {
                    moves.push({ row: newRow, col: newCol });
}
            }

            return moves;
}

        function getBishopMoves(row, col, piece) {
            const moves = [];
const directions = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
for (const [rowDir, colDir] of directions) {
                for (let i = 1; i < 8; i++) {
                    const newRow = row + i * rowDir;
const newCol = col + i * colDir;

                    if (!isInBounds(newRow, newCol)) break;
if (!board[newRow][newCol]) {
                        moves.push({ row: newRow, col: newCol });
} else {
                        if (isWhitePiece(board[newRow][newCol]) !== isWhitePiece(piece)) {
                            moves.push({ row: newRow, col: newCol });
}
                        break;
}
                }
            }

            return moves;
}

        function getQueenMoves(row, col, piece) {
            return [...getRookMoves(row, col, piece), ...getBishopMoves(row, col, piece)];
}

        function getKingMoves(row, col, piece) {
            const moves = [];
const directions = [
                [-1, -1], [-1, 0], [-1, 1],
                [0, -1],           [0, 1],
                [1, -1],  [1, 0],  [1, 1]
            ];
// Movimientos normales del rey
            for (const [rowOffset, colOffset] of directions) {
                const newRow = row + rowOffset;
const newCol = col + colOffset;

                if (isInBounds(newRow, newCol) && 
                    (!board[newRow][newCol] || isWhitePiece(board[newRow][newCol]) !== isWhitePiece(piece))) {
                    moves.push({ row: newRow, col: newCol });
}
            }

            // Enroques
            const color = isWhitePiece(piece) ?
'white' : 'black';
            if (castlingRights[color].king) {
                // Enroque corto (lado del rey)
                if (castlingRights[color].kingside && canCastle(row, col, 'kingside')) {
                    moves.push({ row, col: col + 2, isCastling: true, castlingType: 'kingside' });
}
                
                // Enroque largo (lado de la reina)
                if (castlingRights[color].queenside && canCastle(row, col, 'queenside')) {
                    moves.push({ row, col: col - 2, isCastling: true, castlingType: 'queenside' });
}
            }

            return moves;
}

        function isInBounds(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
}

        function isValidMove(row, col, piece) {
            if (!isInBounds(row, col)) return false;
const targetPiece = board[row][col];
            if (targetPiece && isWhitePiece(targetPiece) === isWhitePiece(piece)) {
                return false;
}

            return true;
}

        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');
indicator.textContent = `Turno: ${currentPlayer === 'white' ? 'Blancas' : 'Negras'}`;
indicator.style.background = currentPlayer === 'white' 
                ?
'linear-gradient(45deg, #f0f0f0, #e0e0e0)' 
                : 'linear-gradient(45deg, #555, #333)';
indicator.style.color = currentPlayer === 'white' ? '#333' : '#fff';
        }

        function canCastle(kingRow, kingCol, side) {
            // Verificar si el camino est√° libre
            if (side === 'kingside') {
                // Enroque corto: verificar casillas f1/f8 y g1/g8
                if (board[kingRow][kingCol + 1] || board[kingRow][kingCol 
+ 2]) {
                    return false;
}
                
                // Verificar que la torre est√© en su posici√≥n
                const rook = board[kingRow][7];
if (!rook || rook.toLowerCase() !== 'r' || isWhitePiece(rook) !== isWhitePiece(board[kingRow][kingCol])) {
                    return false;
}
            } else { // queenside
                // Enroque largo: verificar casillas d1/d8, c1/c8 y b1/b8
                if (board[kingRow][kingCol - 1] || board[kingRow][kingCol - 2] || board[kingRow][kingCol - 3]) {
                    return false;
}
                
                // Verificar que la torre est√© en su posici√≥n
                const rook = board[kingRow][0];
if (!rook || rook.toLowerCase() !== 'r' || isWhitePiece(rook) !== isWhitePiece(board[kingRow][kingCol])) {
                    return false;
}
            }

            // TODO: Verificar que el rey no est√© en jaque y no pase por casillas atacadas
            // Por simplicidad, esta implementaci√≥n b√°sica permite el enroque si el camino est√° libre
            return true;
}

        function executeCastling(kingRow, kingCol, newKingRow, newKingCol) {
            const isKingside = newKingCol > kingCol;
// Mover el rey
            board[newKingRow][newKingCol] = board[kingRow][kingCol];
board[kingRow][kingCol] = null;
            
            // Mover la torre
            if (isKingside) {
                // Enroque corto: torre de h1/h8 a f1/f8
                board[newKingRow][newKingCol - 1] = board[kingRow][7];
board[kingRow][7] = null;
            } else {
                // Enroque largo: torre de a1/a8 a d1/d8
                board[newKingRow][newKingCol + 1] = board[kingRow][0];
board[kingRow][0] = null;
            }
            
            // Actualizar derechos de enroque
            const color = isWhitePiece(board[newKingRow][newKingCol]) ?
'white' : 'black';
            castlingRights[color].king = false;
            castlingRights[color].kingside = false;
            castlingRights[color].queenside = false;
}

        function updateCastlingRights(fromRow, fromCol, piece) {
            const color = isWhitePiece(piece) ?
'white' : 'black';
            
            // Si se mueve el rey, pierde todos los derechos de enroque
            if (piece.toLowerCase() === 'k') {
                castlingRights[color].king = false;
castlingRights[color].kingside = false;
                castlingRights[color].queenside = false;
            }
            
            // Si se mueve una torre, pierde el derecho de enroque de ese lado
            if (piece.toLowerCase() === 'r') {
                if (color === 'white' && fromRow === 7) {
                 
   if (fromCol === 0) castlingRights[color].queenside = false;
                    if (fromCol === 7) castlingRights[color].kingside = false;
} else if (color === 'black' && fromRow === 0) {
                    if (fromCol === 0) castlingRights[color].queenside = false;
if (fromCol === 7) castlingRights[color].kingside = false;
                }
            }
        }

        /* --- FUNCI√ìN A√ëADIDA PARA VOLTEAR --- */
        function flipBoard() {
            const chessboard = document.getElementById('chessboard');
            if (chessboard) {
                chessboard.classList.toggle('board-flipped');
            }
        }

        // Inicializar el juego
        initializeBoard();
// Funci√≥n global para limpiar historial
        function clearMoveHistory() {
            moveHistory = [];
moveNumber = 1;
            updateMovesDisplay();
        }

        // Funci√≥n para descargar el historial como TXT
        function downloadGameHistory() {
            if (moveHistory.length === 0) {
                alert('¬°No hay movimientos para descargar!');
return;
            }

            const currentDate = new Date();
const year = currentDate.getFullYear();
            const month = String(currentDate.getMonth() + 1).padStart(2, '0');
            const day = String(currentDate.getDate()).padStart(2, '0');
const hour = String(currentDate.getHours()).padStart(2, '0');
            
            const dateStr = currentDate.toLocaleDateString('es-ES');
            const timeStr = currentDate.toLocaleTimeString('es-ES');
let txtContent = `PARTIDA DE AJEDREZ
=============================================
Fecha: ${dateStr}
Hora: ${timeStr}
Total de movimientos: ${moveHistory.length}
=============================================

HISTORIAL DE MOVIMIENTOS:
-------------------------\n`;
// Generar los movimientos en formato texto
            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
const whiteMove = moveHistory[i];
                const blackMove = moveHistory[i + 1];
                
                let line = `${moveNum}.`;
                line += ` ${whiteMove?.notation || ''}`;
if (blackMove) {
                    line += ` ${blackMove.notation}`;
}
                
                txtContent += line + '\n';
}

            // Agregar estad√≠sticas
            const totalMoves = moveHistory.length;
const whiteMoves = Math.ceil(totalMoves / 2);
            const blackMoves = Math.floor(totalMoves / 2);
            const specialMoves = moveHistory.filter(move => move.isSpecial).length;
txtContent += `
=============================================
ESTAD√çSTICAS DE LA PARTIDA:
---------------------------------------------
‚Ä¢ Movimientos totales: ${totalMoves}
‚Ä¢ Movimientos de blancas: ${whiteMoves}  
‚Ä¢ Movimientos de negras: ${blackMoves}
‚Ä¢ Enroques y promociones: ${specialMoves}
=============================================

Generado con Ajedrez Moderno
Descargado el ${dateStr} a las ${timeStr}`;
// Crear y descargar el archivo TXT
            const blob = new Blob([txtContent], { type: 'text/plain;charset=utf-8' });
const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            
            const fileName = `partida${year}${month}${day}${hour}.txt`;
            
            link.href = url;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }

        // Funci√≥n para guardar el estado del juego
        function saveGameState() {
            const gameState = {
                board: board.map(row => [...row]),
                currentPlayer: currentPlayer,
                castlingRights: JSON.parse(JSON.stringify(castlingRights)),
     
           moveHistory: [...moveHistory]
            };
gameHistory.push(gameState);
        }

        // Funci√≥n para deshacer el √∫ltimo movimiento
        function undoLastMove() {
            if (gameHistory.length <= 1 || pendingPromotion) {
                return;
// No se puede deshacer si no hay movimientos o hay promoci√≥n pendiente
            }

            // Remover el estado actual
            gameHistory.pop();
// Remover el √∫ltimo movimiento del historial
            if (moveHistory.length > 0) {
                moveHistory.pop();
}

            // Restaurar el estado anterior
            const previousState = gameHistory[gameHistory.length - 1];
board = previousState.board.map(row => [...row]);
            currentPlayer = previousState.currentPlayer;
            castlingRights = JSON.parse(JSON.stringify(previousState.castlingRights));
            
            selectedSquare = null;
            possibleMoves = [];
            
            renderBoard();
            updateTurnIndicator();
            updateMovesDisplay();
updateUndoButton();
        }

        // Funci√≥n para actualizar el estado del bot√≥n deshacer
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
if (gameHistory.length <= 1 || pendingPromotion) {
                undoBtn.classList.add('btn-disabled');
undoBtn.disabled = true;
            } else {
                undoBtn.classList.remove('btn-disabled');
undoBtn.disabled = false;
            }
        }

        // Funci√≥n para copiar historial al portapapeles
        async function copyHistoryToClipboard() {
            if (moveHistory.length === 0) {
                alert('¬°No hay movimientos para copiar!');
return;
            }

            let textContent = 'HISTORIAL DE MOVIMIENTOS:\n';
textContent += '========================\n';

            // Generar los movimientos en formato texto
            for (let i = 0; i < moveHistory.length; i += 2) {
                const moveNum = Math.floor(i / 2) + 1;
const whiteMove = moveHistory[i];
                const blackMove = moveHistory[i + 1];
                
                let line = `${moveNum}.`;
                line += ` ${whiteMove?.notation || ''}`;
if (blackMove) {
                    line += ` ${blackMove.notation}`;
}
                
                textContent += line + '\n';
}

            try {
                await navigator.clipboard.writeText(textContent);
// Feedback visual
                const btn = event.target;
const originalText = btn.textContent;
                btn.textContent = '‚úÖ ¬°Copiado!';
                btn.style.background = 'linear-gradient(45deg, #4caf50, #45a049)';
setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = 'linear-gradient(45deg, #ab47bc, #9c27b0)';
                }, 2000);
} catch (err) {
                // Fallback para navegadores que no soportan clipboard API
                const textArea = document.createElement('textarea');
textArea.value = textContent;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('¬°Historial copiado al portapapeles!');
}
        }

        // Event listener para Ctrl+Z
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'z') {
                event.preventDefault();
                undoLastMove();
            }
        
});
    </script>
</body>
</html>